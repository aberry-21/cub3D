/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cub_parse.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aberry <aberry@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/27 12:40:24 by aberry            #+#    #+#             */
/*   Updated: 2020/12/16 18:30:12 by aberry           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d.h"

/*
**--------------------------->>>>ft_cub_parse<<<<------------------------------
** " > " - Вход в функцию
** ----------------------------------------------------------------------------
** Флаг опущен до тех пор пока не встретиться отличный символ,
** от тех что должны быть параметрах.
** ----------------------------------------------------------------------------
** Параметр value = 0 если все успешно и -1 если где то произошла ошибка
** валидации.
** ----------------------------------------------------------------------------
** ft_cub_parse_valid проверяет состоит строка полностью из пробелов
** или она пустая.
** ----------------------------------------------------------------------------
** Далее разделяем строку на подстроки.
** ----------------------------------------------------------------------------
** Вызываем ft_cub_parse_1 которая вернут -1 в случае не успеха
** и 1 если символ не подходит.
** ----------------------------------------------------------------------------
** > Функция представляет собой развилку в зависимости
** от первого параметра подстроки.
** ----------------------------------------------------------------------------
** Соответсвенно если функция вернула 1, то встречена потенциально начало карты,
** ставим флаг на 1, означающий что все данные до карты считаны.
** ----------------------------------------------------------------------------
** Вызываем ft_cub_parse_3 которая вернут -1 в случае не успеха и 0
** если первая строка карты прошла валидацию.
** ----------------------------------------------------------------------------
** > Проверяем что строка состоит только из '1' и ' ' и все
** > поля структуры заполнены (которые заполняются до начала карты).
** ----------------------------------------------------------------------------
** Чистим память выделенную для подстрок.
** ----------------------------------------------------------------------------
** Потом сразу заходим в следующий if так как с первой строки начала карты нам
** также требуются данные.
** ----------------------------------------------------------------------------
** Вызываем ft_cub_parse_2 которая вернут -1 в случае не успеха и 0 если строка
** карты прошла валидацию.
** ----------------------------------------------------------------------------
** > Функция вызывает ft_cub_parse_valid, чтобы проверить что строка
** > не является пустой или из пробелов.
** ----------------------------------------------------------------------------
** > Функция вызывает ft_size_width которая ищет максимально длинную строку,
** > для параметра map->ft_width_mp.
** ----------------------------------------------------------------------------
** >> Эта функция в свою очередь работает следующим образом:
** >> Находим длину строки и вычитаем количество пробелом до последней единицы.
** >> Если встретили символ отличный от единицы то карта невалидна.
** ----------------------------------------------------------------------------
** > map->ft_height_mp это соответственно количество считанных строк карты.
** > map->ft_width_mp это максимальная ширина которая находится с помощью
** > макроса который находит максимальное значение.
** > map->ft_size_arr_sp это количество айтомов на карте.
** ----------------------------------------------------------------------------
** Возвращаем value, при этом ошибки были обработаны и выведеныю
** ----------------------------------------------------------------------------
** PS Функция проверила первую строку карты на то что она состоит из 1 и
** пробелов и проверили все строки справа на валидность
** ----------------------------------------------------------------------------
*/

int	ft_cub_parse_valid(char *line)
{
	int	i;

	i = 0;
	while (line[i] && line[i] == ' ')
		i++;
	if (!*line || ft_strlen(line) == (size_t)i)
		return (0);
	return (1);
}

int	ft_cub_parse_1(char **str, t_map *map)
{
	if (!ft_strncmp(str[0], "R", 2))
		return (ft_cub_resolution(str, map));
	else if (!ft_strncmp(str[0], "NO", 3))
		return (ft_cub_texture(str, &map->ft_north));
	else if (!ft_strncmp(str[0], "SO", 3))
		return (ft_cub_texture(str, &map->ft_south));
	else if (!ft_strncmp(str[0], "WE", 3))
		return (ft_cub_texture(str, &map->ft_west));
	else if (!ft_strncmp(str[0], "EA", 3))
		return (ft_cub_texture(str, &map->ft_east));
	else if (!ft_strncmp(str[0], "S", 2))
		return (ft_cub_texture(str, &map->ft_t_sprite));
	else if (!ft_strncmp(str[0], "F", 2))
		return (ft_cub_color(str, &map->ft_floor));
	else if (!ft_strncmp(str[0], "C", 2))
		return (ft_cub_color(str, &map->ft_ceilling));
	return (1);
}

int	ft_cub_parse_2(char *line, t_map *map)
{
	int	i;

	if (!ft_cub_parse_valid(line))
		return (ft_error_massage("No valid data\n", 14));
	if ((i = ft_size_width(line)) == -1)
		return (-1);
	else
	{
		map->ft_height_mp++;
		map->ft_width_mp = ft_greater(map->ft_width_mp, (size_t)i);
		map->ft_size_arr_sp += ft_counter_sprite(line);
	}
	return (0);
}

int	ft_cub_parse_3(char *line, t_map *map)
{
	int			i;

	i = -1;
	while (line[++i])
		if ((line[i] != 32 && line[i] != '1') || ft_check_struct(map))
			return (ft_error_massage("No valid map\n", 13));
	return (0);
}

int	ft_cub_parse(char *line, t_map *map)
{
	char		**str;
	int			value;
	static int	flag;

	value = 0;
	if (!flag)
	{
		if (!ft_cub_parse_valid(line))
			return (0);
		if (!(str = ft_split(line, ' ')))
			return (ft_error_massage("Malloc error\n", 13));
		value = ft_cub_parse_1(str, map);
		if (value == 1 && (flag = 1))
			value = ft_cub_parse_3(line, map);
		ft_clear(str);
	}
	if (flag && value != -1)
		value = ft_cub_parse_2(line, map);
	return (value);
}
